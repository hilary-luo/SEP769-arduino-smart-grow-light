#include "arduino_secrets.h"
/*
  Sketch generated by the Arduino IoT Cloud Thing "SEP769 Project"
  https://create.arduino.cc/cloud/things/0a811f1b-eac3-46a3-8196-d4d46bef15f9

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  int lightIntensity;
  int lightOnThreshold;
  int lightStatusInt;
  CloudSchedule schedule;
  bool lightStatus;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include "utilityFunctions.h"

#define DELAY 500                // Delay between two measurements in ms
#define LUMINANCE_HYSTERESIS 300
#define MIN_THRESHOLD 200
#define MAX_THRESHOLD 1800
#define FILTER_PERCENT 0.9       // For a low pass filter on the light intensity sensor reading

int sensorPin = A1;              // select the input pin for the potentiometer
int lightPin = 2;                // select the pin for the LED

void setup() {
  
  Serial.begin(9600);            // Initialize serial and wait for port to open:
  delay(1500);                   // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  initProperties();              // Defined in thingProperties.h
  ArduinoCloud.begin(ArduinoIoTPreferredConnection); // Connect to Arduino IoT Cloud

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  //Set up pins
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(sensorPin, INPUT);
  pinMode(lightPin, OUTPUT);
  digitalWrite(lightPin, true);  // Active low relay - start disabled
  
  printWiFiStatus();

  //Initialize threshold for when to turn the artificial light on
  lightOnThreshold = 1200;
}

void loop() {
  
  ArduinoCloud.update();
  
  //Read from sensor and translate into Lux
  int newReading = rawToLux(analogRead(sensorPin));
  
  //Apply a low pass filter to the raw input
  if (lightIntensity == 0) lightIntensity = newReading;
  else lightIntensity = lightIntensity*FILTER_PERCENT + (newReading*(1-FILTER_PERCENT));
  
  //Determine if the light should be on or off based on the light intensity only
  //Uses hysteresis to ensure that the light doesn't end up flickering on and off
  if ((lightStatus == false) && (lightIntensity < lightOnThreshold)) lightStatus = true;
  else if ((lightStatus == true) && (lightIntensity > (lightOnThreshold + LUMINANCE_HYSTERESIS))) lightStatus = false;
  
  //Drive the built-in light directly based on the light intensity for debugging purposes
  digitalWrite(LED_BUILTIN, lightStatus);
  
  //Drive the built-in light if the cloud schedule is active, if not turn the light off
  if (schedule.isActive()) {
    digitalWrite(lightPin, !lightStatus); //Active low relay
    lightStatusInt = lightStatus; //For graphing purposes
  }
  else {
    digitalWrite(lightPin, true); // Active low relay
    lightStatusInt = 0;
  }

  delay(DELAY);
}

/*
  Since LightOnThreshold is READ_WRITE variable, onLightOnThresholdChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLightOnThresholdChange()  {
  // When the threshold is changed, ensure that it is within reasonable bounds
  if (lightOnThreshold < MIN_THRESHOLD) lightOnThreshold = MIN_THRESHOLD;
  else if (lightOnThreshold > MAX_THRESHOLD) lightOnThreshold = MAX_THRESHOLD;
}

/*
  Since Schedule is READ_WRITE variable, onScheduleChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onScheduleChange()  {
  // Add your code here to act upon Schedule change
}






